#include "pokemon_groups.h"

#include "data.h"
#include "global.h"
#include "global.fieldmap.h"
#include "random.h"
#include "region_map.h"
#include "constants/global.h"
#include "constants/map_groups.h"
#include "main_menu.h"

// Groups are autogenerated by the generate_groups.py script.
#include "autogenerated_pokemon_groups.h"

// https://stackoverflow.com/questions/2351087/what-is-the-best-32bit-hash-function-for-short-strings-tag-names
u32 Hash(const u8 *str)
{
  s8 i;
  u32 h = str[0];
  for (i = 1; i < PLAYER_NAME_LENGTH + 1; ++i) {
    h = 37 * h + str[i];
  }
  return h;
}

// https://stackoverflow.com/questions/2590677/how-do-i-combine-hash-values-in-c0x.
// See also https://github.com/HowardHinnant/hash_append/issues/7
u32 HashCombine(u32 h1, u32 h2)
{
  return h1 ^ (h2 + 0x9e3779b9 + (h1 << 6) + (h1 >> 2));
}

u16 Index(const u16 *group, u32 hash) {
  // group[0] has the group size.
  return (hash % group[0]) + 1;
}

u16 IndexInto(const u16 *group, u32 hash) {
  // group[0] has the group size.
  return group[Index(group, hash)];
}

u32 GameHash() {
  static u32 gGameHash;
  if (gGameHash == 0) {
    gGameHash = Hash(gSaveBlock1Ptr->rivalName);
  }
  return gGameHash + 7;
}

bool8 IsStarterGroup(const u16 * group) {
  if ((group == gGroup_GrassStarter1) ||
      (group == gGroup_GrassStarter2) ||
      (group == gGroup_GrassStarter3) ||
      (group == gGroup_FireStarter1) ||
      (group == gGroup_FireStarter2) ||
      (group == gGroup_FireStarter3) ||
      (group == gGroup_WaterStarter1) ||
      (group == gGroup_WaterStarter2) ||
      (group == gGroup_WaterStarter3)) {
	  return TRUE;
  }
  return FALSE;
}

u32 MapHashFromMapId(bool8 fine, u8 mapGroup, u8 mapNum) {
  static u32 gFineMapHash;
  static u32 gCoarseMapHash;
  static s8 gLastMap;

  const u16 map = (mapGroup << 8) | mapNum;
  u16 coarseMap = map;

  if (map != gLastMap) {
    gFineMapHash = SeededRandom(map * 97);
    gFineMapHash = (gFineMapHash << 16) | SeededRandom(gFineMapHash);
    // Rotate 8 bits so that each half of the hash is
    // impacted by both mapRroup and mapNum.
    gFineMapHash = (gFineMapHash << 8) | (gFineMapHash >> 24);

    if (mapGroup == 1) {
      // Mt. Moon.
      if (map == MAP_MT_MOON_B1F || map == MAP_MT_MOON_B2F) {
        coarseMap = MAP_MT_MOON_1F;
      }

      // Rock Tunnel.
      else if (map == MAP_ROCK_TUNNEL_B1F) {
        coarseMap = MAP_ROCK_TUNNEL_1F;
      }

      // Diglett's Cave.
      else if (map == MAP_DIGLETTS_CAVE_NORTH_ENTRANCE || map == MAP_DIGLETTS_CAVE_SOUTH_ENTRANCE) {
        coarseMap = MAP_DIGLETTS_CAVE_B1F;
      }

      // Pokemon Tower.
      else if (map == MAP_POKEMON_TOWER_4F || map == MAP_POKEMON_TOWER_5F) {
        coarseMap = MAP_POKEMON_TOWER_3F;
      }
      else if (map == MAP_POKEMON_TOWER_7F) {
        coarseMap = MAP_POKEMON_TOWER_6F;
      }

      // Pokemon Mansion.
      else if (map == MAP_POKEMON_MANSION_B1F) {
        coarseMap = MAP_POKEMON_MANSION_1F;
      }
      else if (map == MAP_POKEMON_MANSION_3F) {
        coarseMap = MAP_POKEMON_MANSION_2F;
      }

      // Seafoam Islands.
      else if (map == MAP_SEAFOAM_ISLANDS_B1F || map == MAP_SEAFOAM_ISLANDS_B2F) {
        coarseMap = MAP_SEAFOAM_ISLANDS_1F;
      }
      else if (map == MAP_SEAFOAM_ISLANDS_B4F) {
        coarseMap = MAP_SEAFOAM_ISLANDS_B3F;
      }

      // Victory Road.
      else if (map == MAP_VICTORY_ROAD_2F || map == MAP_VICTORY_ROAD_3F) {
        coarseMap = MAP_VICTORY_ROAD_1F;
      }

      // Mt. Ember.
      else if (map == MAP_MT_EMBER_SUMMIT_PATH_2F || map == MAP_MT_EMBER_SUMMIT_PATH_3F) {
        coarseMap = MAP_MT_EMBER_SUMMIT_PATH_1F;
      }
      // Ruby path is post game so is excluded.
    }

    gCoarseMapHash = SeededRandom(coarseMap * 97);
    gCoarseMapHash = (gCoarseMapHash << 16) | SeededRandom(gCoarseMapHash);
    // Rotate 8 bits so that each half of the hash is
    // impacted by both mapRroup and mapNum.
    gCoarseMapHash = (gCoarseMapHash << 8) | (gCoarseMapHash >> 24);

    gLastMap =  map;
  }

  return fine ? gFineMapHash : gCoarseMapHash;
}

u32 MapHashFromPlayerSpot(bool8 fine) {
  struct WarpData* location = &gSaveBlock1Ptr->location;
  const u16 map = (location->mapGroup << 8) | location->mapNum;

  return MapHashFromMapId(fine, location->mapGroup, location->mapNum);
}

u32 MapHash() {
  return MapHashFromPlayerSpot(TRUE);
}

u32 CoarseMapHash() {
  return MapHashFromPlayerSpot(FALSE);
}

u16 GetSpeciesFromGroup(u16 species, u16 randInput) {
  const u16 *group;
  u8 random;
  u32 combinedHash;
  u32 tempCombinedHash1;
  u32 tempCombinedHash2;
  u32 mapHash;

  if (species >= sizeof(gMonGroups) || gMonGroups[species] == NULL) {
    return species;
  }

  group = gMonGroups[species];

  // if this is a starter, just use the game hash.
  if (IsStarterGroup(group)) {
    // int divide by 3 to preserve evolution chain.
    //
    // don't take route into account, so that rival
    // has the same starter throughout the game.
    combinedHash = HashCombine(GameHash(), Hash(gSpeciesNames[(species + 2) / 3]));
    return IndexInto(group, combinedHash);
  }

  if (randInput != RAND_INPUT_PICK_1 && randInput != RAND_INPUT_PICK_2) {
    // Manual random value was provided.
    // For the 2025 challenge this works completely differently than before.
    random = randInput % 200;
    mapHash = MapHash() + randInput;
    if (random < 8) random += 8;
  } else {
    random = Random() % 200;
    mapHash = CoarseMapHash();
  }

  tempCombinedHash1 = HashCombine(GameHash(), mapHash * species);
  tempCombinedHash2 = HashCombine(mapHash, GameHash() * species);

  if (IndexInto(group, tempCombinedHash1) == IndexInto(group, tempCombinedHash2)) {
    ++tempCombinedHash2;
  }

  if (random < (8 - BadgeCount()) && group != gGroup_WaterIce1 && group != gGroup_WaterIce2) {
    // 0-4% chance that the player found the "rare" species
    // that is unique to the current (non-water) route. We
    // overwrite `group` and ignore `species`.
    group = gGroup_EarlyBoost;
    combinedHash = HashCombine(GameHash(), mapHash);
  } else if (random <= 134) {
    // 63-67% chance the player found the more common mapping to `species`.
    if (randInput == RAND_INPUT_PICK_1 || Index(group, tempCombinedHash1) < Index(group, tempCombinedHash2)) {
      combinedHash = tempCombinedHash1;
    } else {
      combinedHash = tempCombinedHash2;
    }
  } else {
    // 33% chance the player found the less common mapping to `species`.
    if (randInput == RAND_INPUT_PICK_1 || Index(group, tempCombinedHash1) >= Index(group, tempCombinedHash2)) {
      combinedHash = tempCombinedHash1;
    } else {
      combinedHash = tempCombinedHash2;
    }
  }

  return IndexInto(group, combinedHash);
}

